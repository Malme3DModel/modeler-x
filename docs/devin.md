# ğŸ¯ CascadeStudioç§»è¡Œä½œæ¥­ - ãƒ•ã‚§ãƒ¼ã‚º2.2å®Ÿè£…æŒ‡ç¤ºæ›¸

## ğŸ“‹ ä½œæ¥­æ¦‚è¦

**ä½œæ¥­å**: ãƒ•ã‚§ãƒ¼ã‚º2.2 - ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«é«˜åº¦æ©Ÿèƒ½ã®å®Ÿè£…  
**å„ªå…ˆåº¦**: ğŸ”´ é«˜  
**æ‹…å½“è€…**: ã‚ãªãŸ  

## ğŸ¯ ä½œæ¥­ç›®çš„

TransformControlsï¼ˆã‚®ã‚ºãƒ¢æ“ä½œï¼‰ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé¸æŠæ©Ÿèƒ½ã®å®Ÿè£…ãŒå®Œäº†ã—ãŸãŸã‚ã€æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¨ã—ã¦ã€Œã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«é«˜åº¦æ©Ÿèƒ½ã€ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚ç¾åœ¨ã¯åŸºæœ¬çš„ãªOrbitControlsã®ã¿ãŒå‹•ä½œã—ã¦ã„ã¾ã™ãŒã€å…ƒã®CascadeStudioã¨åŒç­‰ã®æ“ä½œæ„Ÿã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«ã€6æ–¹å‘è¦–ç‚¹åˆ‡ã‚Šæ›¿ãˆã€ISOè¦–ç‚¹ã€Fit to Objectæ©Ÿèƒ½ã€ã‚¹ãƒ ãƒ¼ã‚ºãªã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€3D CADã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã—ã¦ã®æ“ä½œæ€§ãŒå¤§å¹…ã«å‘ä¸Šã—ã¾ã™ã€‚

**é‡è¦**: å®Ÿè£…å®Œäº†å¾Œã€å¿…ãšãƒ†ã‚¹ãƒˆã‚’ä½œæˆãƒ»å®Ÿè¡Œã—ã€å…¨ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã—ã¦ã‹ã‚‰å®Œäº†ã¨ã—ã¾ã™ã€‚

## ğŸ“š å¿…é ˆå‚è€ƒè³‡æ–™

### 1. ç§»è¡Œè¨ˆç”»æ›¸
- **`docs/7_cascadestudio_migration/README.md`** - å…¨ä½“æ¦‚è¦ã¨ãƒ•ã‚§ãƒ¼ã‚º2.2ã®è©³ç´°
- **`docs/7_cascadestudio_migration/feature_comparison.md`** - ã‚«ãƒ¡ãƒ©æ©Ÿèƒ½ã®å®Ÿè£…çŠ¶æ³ç¢ºèª
- **`docs/7_cascadestudio_migration/migration_plan.md`** - ã‚¿ã‚¹ã‚¯2.2.1ã€œ2.2.3ã®è©³ç´°å®Ÿè£…è¨ˆç”»
- **`docs/7_cascadestudio_migration/implementation_tasks.md`** - å…·ä½“çš„ãªã‚³ãƒ¼ãƒ‰ä¾‹ã¨ã‚¿ã‚¹ã‚¯è©³ç´°

### 2. å…ƒã®CascadeStudioå®Ÿè£…
- **`docs/template/js/MainPage/CascadeView.js`** - å…ƒã®ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«å®Ÿè£…ï¼ˆè¦–ç‚¹åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½ï¼‰
- **`docs/template/js/MainPage/CascadeMain.js`** - ã‚«ãƒ¡ãƒ©æ“ä½œã®ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
- è¦–ç‚¹ãƒ—ãƒªã‚»ãƒƒãƒˆã€ãƒ•ã‚£ãƒƒãƒˆæ©Ÿèƒ½ã®è©³ç´°ã‚’ç¢ºèªã—ã¦ãã ã•ã„

### 3. ç¾åœ¨ã®å®Ÿè£…
- **`components/threejs/ThreeJSViewport.tsx`** - ç¾åœ¨ã®OrbitControlså®Ÿè£…
- **`components/cad/CameraControls.tsx`** - æ—¢å­˜ã®ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«UIï¼ˆæ”¹è‰¯å¯¾è±¡ï¼‰
- **`components/threejs/TransformGizmo.tsx`** - å®Ÿè£…æ¸ˆã¿TransformControlsï¼ˆå‚è€ƒï¼‰
- **`tests/transform-controls.spec.ts`** - æ—¢å­˜ã®E2Eãƒ†ã‚¹ãƒˆï¼ˆå‚è€ƒï¼‰

## ğŸ”§ å…·ä½“çš„ãªä½œæ¥­å†…å®¹

### ã‚¿ã‚¹ã‚¯2.2.1: è¦–ç‚¹ãƒ—ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½ã®æ”¹è‰¯

**å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `components/cad/CameraControls.tsx` (æ”¹è‰¯)

#### 1.1 ã‚«ãƒ¡ãƒ©ä½ç½®å®šç¾©ã®å®Ÿè£…
```typescript
import { useRef, useCallback } from 'react';
import { useThree } from '@react-three/fiber';
import { Button } from '../ui/button';
import { 
  Eye, 
  RotateCcw, 
  Box, 
  ArrowUp, 
  ArrowDown, 
  ArrowLeft, 
  ArrowRight,
  Maximize2 
} from 'lucide-react';

// 6æ–¹å‘ + ISOè¦–ç‚¹ã®å®šç¾©
const CAMERA_POSITIONS = {
  front: { 
    position: [0, 0, 10] as [number, number, number], 
    target: [0, 0, 0] as [number, number, number],
    name: 'Front'
  },
  back: { 
    position: [0, 0, -10] as [number, number, number], 
    target: [0, 0, 0] as [number, number, number],
    name: 'Back'
  },
  top: { 
    position: [0, 10, 0] as [number, number, number], 
    target: [0, 0, 0] as [number, number, number],
    name: 'Top'
  },
  bottom: { 
    position: [0, -10, 0] as [number, number, number], 
    target: [0, 0, 0] as [number, number, number],
    name: 'Bottom'
  },
  left: { 
    position: [-10, 0, 0] as [number, number, number], 
    target: [0, 0, 0] as [number, number, number],
    name: 'Left'
  },
  right: { 
    position: [10, 0, 0] as [number, number, number], 
    target: [0, 0, 0] as [number, number, number],
    name: 'Right'
  },
  iso: { 
    position: [7, 7, 7] as [number, number, number], 
    target: [0, 0, 0] as [number, number, number],
    name: 'ISO'
  }
};

interface CameraControlsProps {
  onFitToObject?: () => void;
  boundingBox?: THREE.Box3 | null;
}

export function CameraControls({ onFitToObject, boundingBox }: CameraControlsProps) {
  const { camera, controls } = useThree();
  const animationRef = useRef<number>();

  // ã‚¹ãƒ ãƒ¼ã‚ºãªã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  const animateToView = useCallback((viewName: keyof typeof CAMERA_POSITIONS) => {
    if (!controls || !camera) return;

    const view = CAMERA_POSITIONS[viewName];
    const startPosition = camera.position.clone();
    const startTarget = controls.target.clone();
    const endPosition = new THREE.Vector3(...view.position);
    const endTarget = new THREE.Vector3(...view.target);

    // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ãŒã‚ã‚‹å ´åˆã¯è·é›¢ã‚’èª¿æ•´
    if (boundingBox) {
      const size = new THREE.Vector3();
      boundingBox.getSize(size);
      const maxDim = Math.max(size.x, size.y, size.z);
      const distance = maxDim * 2.5; // é©åˆ‡ãªè·é›¢ã«èª¿æ•´
      
      endPosition.normalize().multiplyScalar(distance);
      
      const center = new THREE.Vector3();
      boundingBox.getCenter(center);
      endTarget.copy(center);
      endPosition.add(center);
    }

    let progress = 0;
    const duration = 1000; // 1ç§’ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    const startTime = Date.now();

    const animate = () => {
      const elapsed = Date.now() - startTime;
      progress = Math.min(elapsed / duration, 1);
      
      // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆease-outï¼‰
      const eased = 1 - Math.pow(1 - progress, 3);
      
      // ä½ç½®ã®è£œé–“
      camera.position.lerpVectors(startPosition, endPosition, eased);
      controls.target.lerpVectors(startTarget, endTarget, eased);
      
      controls.update();
      
      if (progress < 1) {
        animationRef.current = requestAnimationFrame(animate);
      }
    };

    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    
    animate();
  }, [camera, controls, boundingBox]);

  return (
    <div className="flex flex-col gap-2 p-2 bg-white border rounded-lg shadow-sm">
      <div className="text-sm font-medium text-gray-700 mb-2">Camera Views</div>
      
      {/* 6æ–¹å‘è¦–ç‚¹ãƒœã‚¿ãƒ³ */}
      <div className="grid grid-cols-3 gap-1">
        <Button
          variant="outline"
          size="sm"
          onClick={() => animateToView('top')}
          className="flex items-center gap-1"
        >
          <ArrowUp className="w-3 h-3" />
          Top
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => animateToView('front')}
          className="flex items-center gap-1"
        >
          <Eye className="w-3 h-3" />
          Front
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => animateToView('right')}
          className="flex items-center gap-1"
        >
          <ArrowRight className="w-3 h-3" />
          Right
        </Button>
        
        <Button
          variant="outline"
          size="sm"
          onClick={() => animateToView('left')}
          className="flex items-center gap-1"
        >
          <ArrowLeft className="w-3 h-3" />
          Left
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => animateToView('back')}
          className="flex items-center gap-1"
        >
          <RotateCcw className="w-3 h-3" />
          Back
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => animateToView('bottom')}
          className="flex items-center gap-1"
        >
          <ArrowDown className="w-3 h-3" />
          Bottom
        </Button>
      </div>
      
      {/* ISOè¦–ç‚¹ã¨Fit to Objectãƒœã‚¿ãƒ³ */}
      <div className="flex gap-1 mt-2">
        <Button
          variant="outline"
          size="sm"
          onClick={() => animateToView('iso')}
          className="flex items-center gap-1 flex-1"
        >
          <Box className="w-3 h-3" />
          ISO
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={onFitToObject}
          className="flex items-center gap-1 flex-1"
          disabled={!boundingBox}
        >
          <Maximize2 className="w-3 h-3" />
          Fit
        </Button>
      </div>
    </div>
  );
}
```

### ã‚¿ã‚¹ã‚¯2.2.2: Fit to Objectæ©Ÿèƒ½ã®å®Ÿè£…

**å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `hooks/useCameraAnimation.ts` (æ–°è¦ä½œæˆ)

#### 2.1 ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒƒã‚¯ã®ä½œæˆ
```typescript
import { useCallback, useRef } from 'react';
import { useThree } from '@react-three/fiber';
import * as THREE from 'three';

export function useCameraAnimation() {
  const { camera, controls } = useThree();
  const animationRef = useRef<number>();

  const fitToObject = useCallback((boundingBox: THREE.Box3) => {
    if (!controls || !camera || !boundingBox) return;

    // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã®ä¸­å¿ƒã¨ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
    const center = new THREE.Vector3();
    boundingBox.getCenter(center);
    
    const size = new THREE.Vector3();
    boundingBox.getSize(size);
    
    // æœ€å¤§å¯¸æ³•ã‚’å–å¾—
    const maxDim = Math.max(size.x, size.y, size.z);
    
    // ã‚«ãƒ¡ãƒ©ã®è¦–é‡è§’ã«åŸºã¥ã„ã¦é©åˆ‡ãªè·é›¢ã‚’è¨ˆç®—
    const fov = camera.fov * (Math.PI / 180); // ãƒ©ã‚¸ã‚¢ãƒ³ã«å¤‰æ›
    const distance = maxDim / (2 * Math.tan(fov / 2)) * 1.5; // 1.5å€ã®ãƒãƒ¼ã‚¸ãƒ³
    
    // ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©æ–¹å‘ã‚’ç¶­æŒã—ã¦è·é›¢ã‚’èª¿æ•´
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);
    direction.negate(); // ã‚«ãƒ¡ãƒ©ã‹ã‚‰è¦‹ãŸæ–¹å‘ã®é€†
    
    const targetPosition = center.clone().add(direction.multiplyScalar(distance));
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
    const startPosition = camera.position.clone();
    const startTarget = controls.target.clone();
    
    let progress = 0;
    const duration = 1500; // 1.5ç§’ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    const startTime = Date.now();

    const animate = () => {
      const elapsed = Date.now() - startTime;
      progress = Math.min(elapsed / duration, 1);
      
      // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆease-in-outï¼‰
      const eased = progress < 0.5 
        ? 2 * progress * progress 
        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
      
      // ä½ç½®ã¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®è£œé–“
      camera.position.lerpVectors(startPosition, targetPosition, eased);
      controls.target.lerpVectors(startTarget, center, eased);
      
      controls.update();
      
      if (progress < 1) {
        animationRef.current = requestAnimationFrame(animate);
      }
    };

    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    
    animate();
  }, [camera, controls]);

  const animateToPosition = useCallback((
    position: THREE.Vector3, 
    target: THREE.Vector3, 
    duration: number = 1000
  ) => {
    if (!controls || !camera) return;

    const startPosition = camera.position.clone();
    const startTarget = controls.target.clone();
    
    let progress = 0;
    const startTime = Date.now();

    const animate = () => {
      const elapsed = Date.now() - startTime;
      progress = Math.min(elapsed / duration, 1);
      
      // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆease-outï¼‰
      const eased = 1 - Math.pow(1 - progress, 3);
      
      camera.position.lerpVectors(startPosition, position, eased);
      controls.target.lerpVectors(startTarget, target, eased);
      
      controls.update();
      
      if (progress < 1) {
        animationRef.current = requestAnimationFrame(animate);
      }
    };

    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    
    animate();
  }, [camera, controls]);

  return {
    fitToObject,
    animateToPosition
  };
}
```

### ã‚¿ã‚¹ã‚¯2.2.3: ThreeJSViewportã¸ã®çµ±åˆ

**å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `components/threejs/ThreeJSViewport.tsx` (æ”¹è‰¯)

#### 3.1 ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®çµ±åˆ
```typescript
import { CameraControls } from '../cad/CameraControls';
import { useCameraAnimation } from '../../hooks/useCameraAnimation';

// æ—¢å­˜ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…ã§
export default function ThreeJSViewport() {
  const [boundingBox, setBoundingBox] = useState<THREE.Box3 | null>(null);
  const { fitToObject } = useCameraAnimation();

  // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã®è¨ˆç®—ï¼ˆæ—¢å­˜ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ´»ç”¨ï¼‰
  const calculateBoundingBox = useCallback((objects: THREE.Object3D[]) => {
    if (objects.length === 0) return null;
    
    const box = new THREE.Box3();
    objects.forEach(obj => {
      const objBox = new THREE.Box3().setFromObject(obj);
      box.union(objBox);
    });
    
    return box;
  }, []);

  // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ›´æ–°ã•ã‚ŒãŸæ™‚ã«ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’å†è¨ˆç®—
  useEffect(() => {
    if (meshObjects.length > 0) {
      const box = calculateBoundingBox(meshObjects);
      setBoundingBox(box);
    }
  }, [meshObjects, calculateBoundingBox]);

  const handleFitToObject = useCallback(() => {
    if (boundingBox) {
      fitToObject(boundingBox);
    }
  }, [boundingBox, fitToObject]);

  return (
    <div className="relative w-full h-full">
      <Canvas
        // æ—¢å­˜ã®props
      >
        {/* æ—¢å­˜ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ */}
      </Canvas>
      
      {/* ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«UIã‚’è¿½åŠ  */}
      <div className="absolute top-4 right-4 z-10">
        <CameraControls 
          onFitToObject={handleFitToObject}
          boundingBox={boundingBox}
        />
      </div>
      
      {/* æ—¢å­˜ã®TransformControlsUI */}
      <div className="absolute bottom-4 left-4 z-10">
        <TransformControlsUI 
          // æ—¢å­˜ã®props
        />
      </div>
    </div>
  );
}
```

### ã‚¿ã‚¹ã‚¯2.2.4: ã‚«ãƒ¡ãƒ©è¨­å®šã®æœ€é©åŒ–

**å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `components/threejs/ThreeJSViewport.tsx` (æ”¹è‰¯)

#### 4.1 OrbitControlsã®è¨­å®šèª¿æ•´
```typescript
// OrbitControlsã®è¨­å®šã‚’å…ƒã®CascadeStudioã«åˆã‚ã›ã¦èª¿æ•´
<OrbitControls
  ref={controlsRef}
  enablePan={true}
  enableZoom={true}
  enableRotate={true}
  dampingFactor={0.05}
  enableDamping={true}
  minDistance={1}
  maxDistance={1000}
  minPolarAngle={0}
  maxPolarAngle={Math.PI}
  minAzimuthAngle={-Infinity}
  maxAzimuthAngle={Infinity}
  panSpeed={1.0}
  rotateSpeed={1.0}
  zoomSpeed={1.0}
  mouseButtons={{
    LEFT: THREE.MOUSE.ROTATE,
    MIDDLE: THREE.MOUSE.DOLLY,
    RIGHT: THREE.MOUSE.PAN
  }}
  touches={{
    ONE: THREE.TOUCH.ROTATE,
    TWO: THREE.TOUCH.DOLLY_PAN
  }}
/>
```

### ã‚¿ã‚¹ã‚¯2.2.5: E2Eãƒ†ã‚¹ãƒˆã®ä½œæˆ

**å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `tests/camera-controls.spec.ts` (æ–°è¦ä½œæˆ)

#### 5.1 ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®ãƒ†ã‚¹ãƒˆå®Ÿè£…
```typescript
import { test, expect } from '@playwright/test';

test.describe('Camera Controls', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await page.waitForSelector('[data-testid="3d-viewport"]');
    
    // åŸºæœ¬çš„ãªCADã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆ
    await page.click('[data-testid="monaco-editor"]');
    await page.keyboard.type(`
      let box = new oc.BRepPrimAPI_MakeBox(10, 10, 10).Shape();
      cacheShape(box);
    `);
    await page.keyboard.press('F5');
    await page.waitForTimeout(2000); // CADæ¼”ç®—å®Œäº†å¾…ã¡
  });

  test('è¦–ç‚¹ãƒ—ãƒªã‚»ãƒƒãƒˆåˆ‡ã‚Šæ›¿ãˆãŒå‹•ä½œã™ã‚‹', async ({ page }) => {
    // Frontè¦–ç‚¹
    await page.click('[data-testid="camera-front"]');
    await page.waitForTimeout(1500); // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†å¾…ã¡
    
    // Topè¦–ç‚¹
    await page.click('[data-testid="camera-top"]');
    await page.waitForTimeout(1500);
    
    // ISOè¦–ç‚¹
    await page.click('[data-testid="camera-iso"]');
    await page.waitForTimeout(1500);
    
    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
    const errors = await page.evaluate(() => {
      return window.console.error.calls || [];
    });
    expect(errors.length).toBe(0);
  });

  test('Fit to Objectæ©Ÿèƒ½ãŒå‹•ä½œã™ã‚‹', async ({ page }) => {
    // Fit to Objectãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
    await page.click('[data-testid="camera-fit"]');
    await page.waitForTimeout(1500); // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†å¾…ã¡
    
    // ã‚«ãƒ¡ãƒ©ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ•ã‚£ãƒƒãƒˆã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
    // ï¼ˆå…·ä½“çš„ãªä½ç½®ç¢ºèªã¯å®Ÿè£…ã«å¿œã˜ã¦èª¿æ•´ï¼‰
    const cameraPosition = await page.evaluate(() => {
      const canvas = document.querySelector('canvas');
      return canvas ? 'positioned' : 'not found';
    });
    expect(cameraPosition).toBe('positioned');
  });

  test('ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚¹ãƒ ãƒ¼ã‚ºã«å‹•ä½œã™ã‚‹', async ({ page }) => {
    // è¤‡æ•°ã®è¦–ç‚¹ã‚’é€£ç¶šã§åˆ‡ã‚Šæ›¿ãˆ
    await page.click('[data-testid="camera-front"]');
    await page.waitForTimeout(500);
    
    await page.click('[data-testid="camera-right"]');
    await page.waitForTimeout(500);
    
    await page.click('[data-testid="camera-top"]');
    await page.waitForTimeout(1500);
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
    const consoleErrors = await page.evaluate(() => {
      return window.console.error.calls || [];
    });
    expect(consoleErrors.length).toBe(0);
  });

  test('æ—¢å­˜ã®TransformControlsã¨ã®ç«¶åˆãŒãªã„', async ({ page }) => {
    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é¸æŠ
    await page.click('[data-testid="3d-viewport"]');
    await page.waitForTimeout(500);
    
    // TransformControlsãŒè¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
    await expect(page.locator('[data-testid="transform-gizmo"]')).toBeVisible();
    
    // ã‚«ãƒ¡ãƒ©è¦–ç‚¹ã‚’å¤‰æ›´
    await page.click('[data-testid="camera-iso"]');
    await page.waitForTimeout(1500);
    
    // TransformControlsãŒå¼•ãç¶šãå‹•ä½œã™ã‚‹ã“ã¨ã‚’ç¢ºèª
    await expect(page.locator('[data-testid="transform-gizmo"]')).toBeVisible();
  });
});
```

## âœ… å®Œäº†æ¡ä»¶

### å¿…é ˆè¦ä»¶
1. **6æ–¹å‘è¦–ç‚¹åˆ‡ã‚Šæ›¿ãˆ**: Front/Back/Top/Bottom/Left/Rightè¦–ç‚¹ãŒæ­£å¸¸ã«å‹•ä½œ
2. **ISOè¦–ç‚¹**: ã‚¢ã‚¤ã‚½ãƒ¡ãƒˆãƒªãƒƒã‚¯è¦–ç‚¹ãŒæ­£å¸¸ã«å‹•ä½œ
3. **ã‚¹ãƒ ãƒ¼ã‚ºã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³**: è¦–ç‚¹åˆ‡ã‚Šæ›¿ãˆæ™‚ã«1-1.5ç§’ã®ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
4. **Fit to Objectæ©Ÿèƒ½**: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã«åŸºã¥ãè‡ªå‹•ãƒ•ã‚£ãƒƒãƒˆ
5. **UIçµ±åˆ**: æ—¢å­˜ã®TransformControlsUIã¨ç«¶åˆã—ãªã„é…ç½®
6. **E2Eãƒ†ã‚¹ãƒˆ**: å…¨ã¦ã®æ©Ÿèƒ½ãŒè‡ªå‹•ãƒ†ã‚¹ãƒˆã§ã‚«ãƒãƒ¼ã•ã‚Œã¦ã„ã‚‹

### å“è³ªè¦ä»¶
1. **TypeScriptå‹å®‰å…¨æ€§**: å…¨ã¦ã®æ–°è¦ã‚³ãƒ¼ãƒ‰ãŒstrict modeã«æº–æ‹ 
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆç¶­æŒ
3. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: é©åˆ‡ãªã‚¨ãƒ©ãƒ¼å‡¦ç†ã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
4. **æ—¢å­˜æ©Ÿèƒ½ã¨ã®äº’æ›æ€§**: ãƒ›ãƒãƒ¼ãƒã‚¤ãƒ©ã‚¤ãƒˆã€TransformControlsã¨ã®ç«¶åˆãªã—

## ğŸ§ª ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ‰‹é †

```bash
# é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•
npm run dev

# E2Eãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run test

# æ–°è¦ãƒ†ã‚¹ãƒˆã®ã¿å®Ÿè¡Œ
npx playwright test tests/camera-controls.spec.ts

# ãƒ˜ãƒƒãƒ‰ä»˜ããƒ†ã‚¹ãƒˆï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
npx playwright test tests/camera-controls.spec.ts --headed
```

## ğŸ“ å®Ÿè£…å®Œäº†å¾Œã®ç¢ºèªäº‹é …

1. **æ©Ÿèƒ½ç¢ºèª**:
   - [ ] 6æ–¹å‘è¦–ç‚¹åˆ‡ã‚Šæ›¿ãˆãŒæ­£å¸¸å‹•ä½œ
   - [ ] ISOè¦–ç‚¹ãŒæ­£å¸¸å‹•ä½œ
   - [ ] Fit to Objectæ©Ÿèƒ½ãŒæ­£å¸¸å‹•ä½œ
   - [ ] ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚¹ãƒ ãƒ¼ã‚º
   - [ ] æ—¢å­˜ã®TransformControlsã¨ã®ç«¶åˆãªã—

2. **ãƒ†ã‚¹ãƒˆç¢ºèª**:
   - [ ] æ–°è¦E2Eãƒ†ã‚¹ãƒˆãŒå…¨ã¦ãƒ‘ã‚¹
   - [ ] æ—¢å­˜ãƒ†ã‚¹ãƒˆãŒå¼•ãç¶šããƒ‘ã‚¹
   - [ ] TypeScriptå‹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼ãªã—

3. **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°**:
   - [ ] `docs/7_cascadestudio_migration/feature_comparison.md`ã®æ›´æ–°
   - [ ] `docs/7_cascadestudio_migration/implementation_tasks.md`ã®é€²æ—æ›´æ–°

## ğŸš¨ æ³¨æ„äº‹é …

1. **OrbitControlsã¨ã®ç«¶åˆ**: TransformControlsã¨åŒæ§˜ã«ã€ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã¯OrbitControlsã‚’é©åˆ‡ã«åˆ¶å¾¡ã—ã¦ãã ã•ã„
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã®requestAnimationFrameã®é©åˆ‡ãªç®¡ç†
3. **ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹**: ç©ºã®ã‚·ãƒ¼ãƒ³ã‚„ç„¡åŠ¹ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹é©åˆ‡ãªå‡¦ç†
4. **æ—¢å­˜æ©Ÿèƒ½ã®ä¿æŒ**: ãƒ›ãƒãƒ¼ãƒã‚¤ãƒ©ã‚¤ãƒˆã€TransformControlsãªã©ã®æ—¢å­˜æ©Ÿèƒ½ã‚’ç ´å£Šã—ãªã„ã‚ˆã†æ³¨æ„

## ğŸ“ ã‚µãƒãƒ¼ãƒˆ

å®Ÿè£…ä¸­ã«å•é¡ŒãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€ä»¥ä¸‹ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ï¼š
- å…ƒã®CascadeStudioå®Ÿè£…: `docs/template/js/MainPage/CascadeView.js`
- React Three Fiberå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ: https://docs.pmnd.rs/react-three-fiber
- Three.js OrbitControls: https://threejs.org/docs/#examples/en/controls/OrbitControls

ã“ã®å®Ÿè£…ã«ã‚ˆã‚Šã€ãƒ•ã‚§ãƒ¼ã‚º2.2ãŒå®Œäº†ã—ã€å…ƒã®CascadeStudioã¨åŒç­‰ã®ã‚«ãƒ¡ãƒ©æ“ä½œæ©Ÿèƒ½ãŒå®Ÿç¾ã•ã‚Œã¾ã™ã€‚ 