import { useState, useEffect, useRef, useCallback } from 'react';
import type { 
  CADWorkerMessage, 
  CADWorkerResponse, 
  CADShape, 
  GUIState,
  EvaluationPayload,
  CombineAndRenderPayload,
  ProgressPayload,
  WorkerError
} from '@/types/worker';

interface UseCADWorkerReturn {
  worker: Worker | null;
  isWorkerReady: boolean;
  isWorking: boolean;
  shapes: CADShape[];
  logs: string[];
  error: string | null;
  progress: ProgressPayload | null;
  executeCADCode: (code: string, guiState?: GUIState) => Promise<void>;
  combineAndRender: (options?: CombineAndRenderPayload) => Promise<void>;
  clearLogs: () => void;
  clearError: () => void;
  sendToWorker: (message: { type: string; payload: any }) => Promise<any>;
}

/**
 * CAD„ÉØ„Éº„Ç´„Éº„Çí‰ΩøÁî®„Åô„Çã„Åü„ÇÅ„ÅÆ„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ
 * 
 * OpenCascade.js„Çí‰ΩøÁî®„Åó„ÅüCADÊìç‰Ωú„ÇíWebWorker„ÅßÂÆüË°å„Åô„Çã„Åü„ÇÅ„ÅÆ
 * „Éï„ÉÉ„ÇØ„Åß„Åô„ÄÇ„Ç≥„Éº„Éâ„ÅÆË©ï‰æ°„ÄÅÂΩ¢Áä∂„ÅÆ„É¨„É≥„ÉÄ„É™„É≥„Ç∞„ÄÅ„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ
 */
class CADWorkerManager {
  private static instance: CADWorkerManager | null = null;
  private worker: Worker | null = null;
  private isReady: boolean = false;
  private isInitializing: boolean = false;
  private readyCallbacks: (() => void)[] = [];

  private constructor() {}

  static getInstance(): CADWorkerManager {
    if (!CADWorkerManager.instance) {
      CADWorkerManager.instance = new CADWorkerManager();
      (window as any).cadWorkerManager = CADWorkerManager.instance;
    }
    return CADWorkerManager.instance;
  }

  getWorker(): Worker | null {
    return this.worker;
  }

  isWorkerReady(): boolean {
    return this.isReady;
  }

  isWorkerInitializing(): boolean {
    return this.isInitializing;
  }

  setWorker(worker: Worker): void {
    this.worker = worker;
  }

  setReady(ready: boolean): void {
    this.isReady = ready;
    if (ready) {
      this.isInitializing = false;
      this.readyCallbacks.forEach(callback => callback());
      this.readyCallbacks = [];
    }
  }

  setInitializing(initializing: boolean): void {
    this.isInitializing = initializing;
  }

  onReady(callback: () => void): void {
    if (this.isReady) {
      callback();
    } else {
      this.readyCallbacks.push(callback);
    }
  }
}

const workerManager = CADWorkerManager.getInstance();

export function useCADWorker(): UseCADWorkerReturn {
  const workerRef = useRef<Worker | null>(null);
  const isInitializingRef = useRef(false);
  const [isWorkerReady, setIsWorkerReady] = useState(false);
  const [isWorking, setIsWorking] = useState(false);
  const [shapes, setShapes] = useState<CADShape[]>([]);
  const [logs, setLogs] = useState<string[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [progress, setProgress] = useState<ProgressPayload | null>(null);

  // „É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É©„Éº„Éû„ÉÉ„Éó
  const messageHandlers = useRef<Record<string, (payload: any) => void>>({});

  // „É≠„Ç∞„ÅÆËøΩÂä†„Å®„Ç≠„É£„ÉÉ„Ç∑„É•Ôºà„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©ÂåñÔºâ
  const addLog = useCallback((log: string) => {
    // ÊúÄÂ§ß500‰ª∂„Åæ„Åß„Ç≠„É£„ÉÉ„Ç∑„É•
    setLogs(prevLogs => {
      const newLogs = [...prevLogs, log];
      return newLogs.slice(-500);
    });
  }, []);

  // „ÉØ„Éº„Ç´„Éº„ÅÆÂàùÊúüÂåñ
  useEffect(() => {
    if (workerManager.getWorker() && workerManager.isWorkerReady()) {
      console.log("üîÑ [useCADWorker] Using existing worker");
      workerRef.current = workerManager.getWorker();
      setIsWorkerReady(true);
      return;
    }

    if (workerManager.isWorkerInitializing()) {
      console.log("üîÑ [useCADWorker] Worker is initializing, waiting...");
      workerManager.onReady(() => {
        console.log("‚úÖ [useCADWorker] Worker ready, using it");
        workerRef.current = workerManager.getWorker();
        setIsWorkerReady(true);
      });
      return;
    }

    let worker: Worker | null = null;
    let initTimeout: NodeJS.Timeout | null = null;

    workerManager.setInitializing(true);
    isInitializingRef.current = true;
    console.log("üîß [useCADWorker] Starting WebWorker initialization...");

    try {
      // WebWorker API„ÅÆ„Çµ„Éù„Éº„Éà„ÉÅ„Çß„ÉÉ„ÇØ
      if (typeof Worker === 'undefined') {
        throw new Error('WebWorker is not supported in this browser');
      }

      const basePath = process.env.NODE_ENV === 'production' ? '/modeler-x' : '';
      const workerPath = `${basePath}/workers/cadWorker.js`;
      console.log(`üîß [useCADWorker] Attempting to create Worker('${workerPath}')...`);
      worker = new Worker(workerPath);
      console.log("‚úÖ [useCADWorker] Worker created successfully:", worker);
      
      workerManager.setWorker(worker);
      workerRef.current = worker;

      // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÂá¶ÁêÜ„ÅÆË®≠ÂÆöÔºà10Áßí„ÅßÂàùÊúüÂåñÂ§±Êïó„Å®Âà§Êñ≠Ôºâ
      initTimeout = setTimeout(() => {
        if (!isWorkerReady) {
          setError('Worker initialization timed out after 10 seconds');
          console.error('üö® [useCADWorker] Worker initialization timed out');
        }
      }, 10000);

      // „É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É©„Éº„ÅÆË®≠ÂÆö
      messageHandlers.current = {
        startupCallback: () => {
          console.log('‚úÖ [useCADWorker] Received startupCallback - Worker is ready!');
          workerManager.setReady(true);
          setIsWorkerReady(true);
          setError(null);
          isInitializingRef.current = false;
          
          console.log('üìä WebAssembly initialization completed with optimization');
          
          // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÅÆ„ÇØ„É™„Ç¢
          if (initTimeout) {
            clearTimeout(initTimeout);
            initTimeout = null;
          }
        },
        
        log: (payload: string) => {
          console.log('üìã [useCADWorker] Worker log:', payload);
          addLog(payload);
        },
        
        error: (payload: WorkerError) => {
          console.error('‚ùå [useCADWorker] Worker error:', payload);
          setError(payload.message);
          setIsWorking(false);
        },
        
        resetWorking: () => {
          console.log('üîÑ [useCADWorker] Reset working state');
          setIsWorking(false);
        },
        
        Progress: (payload: ProgressPayload) => {
          console.log('üìä [useCADWorker] Progress:', payload);
          setProgress(payload);
        },
        
        Evaluate: (payload: any) => {
          console.log('üîç [useCADWorker] Evaluation completed:', payload);
        },
        
        combineAndRenderShapes: (payload: any) => {
          console.log('üé® [useCADWorker] Combine and render:', payload);
          
          if (payload && payload.meshes && Array.isArray(payload.meshes)) {
            console.log('üîç [useCADWorker] Processing meshes:', payload.meshes.length);
            
            if (payload.meshes.length > 0) {
              // Ë§áÊï∞„ÅÆ„É°„ÉÉ„Ç∑„É•„ÇíÁµ±Âêà„Åó„Å¶CADShapeÂΩ¢Âºè„Å´Â§âÊèõ
              let vertices: number[] = [], normals: number[] = [], indices: number[] = [];
              let vertexOffset = 0;
              
              payload.meshes.forEach((mesh: any, index: number) => {
                console.log(`üîß [useCADWorker] Processing mesh ${index + 1}:`, {
                  vertices: mesh.vertices?.length,
                  normals: mesh.normals?.length,
                  indices: mesh.indices?.length
                });
                
                if (mesh.vertices && mesh.normals && mesh.indices) {
                  vertices.push(...mesh.vertices);
                  normals.push(...mesh.normals);
                  
                  for (let i = 0; i < mesh.indices.length; i++) {
                    indices.push(mesh.indices[i] + vertexOffset);
                  }
                  
                  vertexOffset += mesh.vertices.length / 3;
                }
              });
              
              const newShape: CADShape = {
                hash: Date.now().toString(),
                mesh: {
                  vertices: new Float32Array(vertices),
                  normals: new Float32Array(normals),
                  indices: new Uint16Array(indices)
                }
              };
              
              setShapes([newShape]);
              console.log('‚úÖ [useCADWorker] Shapes rendered:', {
                meshCount: payload.meshes.length,
                vertexCount: vertices.length / 3,
                triangleCount: indices.length / 3,
                shape: newShape
              });
            } else {
              console.warn('‚ö†Ô∏è [useCADWorker] No valid meshes received');
              setShapes([]);
            }
          } else {
            console.warn('‚ö†Ô∏è [useCADWorker] Invalid payload format received:', payload);
            setShapes([]);
          }
          setIsWorking(false);
        }
      };

      // „ÉØ„Éº„Ç´„Éº„Åã„Çâ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜ
      worker.onmessage = (e: MessageEvent<CADWorkerResponse>) => {
        console.log('üì® [useCADWorker] Message received from worker:', e.data);
        const { type, payload } = e.data;
        
        if (messageHandlers.current[type]) {
          messageHandlers.current[type](payload);
        } else {
          console.warn('‚ö†Ô∏è [useCADWorker] Unknown message type from worker:', type, payload);
        }
      };

      // „ÉØ„Éº„Ç´„Éº„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
      worker.onerror = (error) => {
        console.error('üö® [useCADWorker] Worker onerror:', error);
        console.error('üö® [useCADWorker] Error details:', {
          message: error.message,
          filename: error.filename,
          lineno: error.lineno,
          colno: error.colno,
          error: error.error
        });
        
        // „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊï¥ÂΩ¢
        const errorMessage = `Worker error: ${error.message} (${error.filename}:${error.lineno}:${error.colno})`;
        setError(errorMessage);
        addLog(`‚ùå ${errorMessage}`);
        
        setIsWorkerReady(false);
        setIsWorking(false);
        workerManager.setInitializing(false);
        isInitializingRef.current = false;
      };

      // ËøΩÂä†: „ÉØ„Éº„Ç´„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
      worker.onmessageerror = (error) => {
        console.error('üö® [useCADWorker] Worker onmessageerror:', error);
        const errorMessage = `Worker message error: ${error}`;
        setError(errorMessage);
        addLog(`‚ùå ${errorMessage}`);
        workerManager.setInitializing(false);
        isInitializingRef.current = false;
      };

      console.log("üîß [useCADWorker] Event handlers attached successfully");

    } catch (err) {
      console.error('üö® [useCADWorker] Failed to create worker:', err);
      console.error('üö® [useCADWorker] Error type:', err instanceof Error ? err.constructor.name : typeof err);
      console.error('üö® [useCADWorker] Error message:', err instanceof Error ? err.message : String(err));
      console.error('üö® [useCADWorker] Error stack:', err instanceof Error ? err.stack : 'No stack trace');
      
      const errorMessage = `Failed to create worker: ${err instanceof Error ? err.message : 'Unknown error'}`;
      setError(errorMessage);
      addLog(`‚ùå ${errorMessage}`);
      workerManager.setInitializing(false);
      isInitializingRef.current = false;
      
      // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÅÆ„ÇØ„É™„Ç¢
      if (initTimeout) {
        clearTimeout(initTimeout);
        initTimeout = null;
      }
    }

    // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    return () => {
      console.log("üßπ [useCADWorker] Cleaning up worker...");
      
      // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÅÆ„ÇØ„É™„Ç¢
      if (initTimeout) {
        clearTimeout(initTimeout);
        initTimeout = null;
      }
      
      if (worker && worker === workerManager.getWorker()) {
        console.log("üßπ [useCADWorker] Cleaning up local worker reference (keeping managed worker alive)");
        workerRef.current = null;
      } else if (worker) {
        worker.terminate();
        workerRef.current = null;
        console.log("‚úÖ [useCADWorker] Worker terminated");
      }
      
      isInitializingRef.current = false;
    };
  }, []);

  // CAD„Ç≥„Éº„Éâ„ÅÆÂÆüË°å
  const executeCADCode = useCallback(async (code: string, guiState: GUIState = {}): Promise<void> => {
    const workerManager = (window as any).cadWorkerManager;
    const isWorkerActuallyReady = workerManager?.isWorkerReady() || false;
    const worker = workerManager?.getWorker() || workerRef.current;
    
    if (!worker || !isWorkerActuallyReady) {
      throw new Error('Worker not ready');
    }

    setIsWorking(true);
    setError(null);
    setProgress(null);
    
    // „Ç≥„Éº„ÉâÂÆüË°å„ÅÆÈñãÂßã„Çí„É≠„Ç∞„Å´Ë®òÈå≤
    addLog(`üîÑ „Ç≥„Éº„ÉâË©ï‰æ°„ÇíÈñãÂßã: ${code.length}ÊñáÂ≠ó„ÅÆ„Ç≥„Éº„Éâ`);

    // „Éá„Éï„Ç©„É´„Éà„ÅÆGUIÁä∂ÊÖã„Å®„Éû„Éº„Ç∏
    const payload: EvaluationPayload = {
      code,
      GUIState: {
        "Cache?": true,
        "MeshRes": 0.1,
        "GroundPlane?": true,
        "Grid?": true,
        ...guiState
      }
    };

    const message: CADWorkerMessage = {
      type: 'Evaluate',
      payload
    };

    // Promise„Éô„Éº„Çπ„Åß„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°
    return new Promise((resolve, reject) => {
      if (!workerRef.current) {
        reject(new Error('Worker not available'));
        return;
      }
      
      // ‰∏ÄÂÆöÊôÇÈñìÂæå„Å´„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Ç®„É©„Éº„ÇíÁô∫Áîü„Åï„Åõ„Çã
      const timeoutId = setTimeout(() => {
        setIsWorking(false);
        const timeoutError = new Error('CAD evaluation timed out after 30 seconds');
        setError(timeoutError.message);
        addLog(`‚ùå ${timeoutError.message}`);
        reject(timeoutError);
      }, 30000);
      
      // ÂÆå‰∫Ü„Ç§„Éô„É≥„Éà„ÇíÂæÖÊ©ü„Åô„Çã„Éè„É≥„Éâ„É©„Éº
      const handleCompletion = (e: MessageEvent<CADWorkerResponse>) => {
        const { type } = e.data;
        if (type === 'combineAndRenderShapes') {
          clearTimeout(timeoutId);
          workerRef.current?.removeEventListener('message', handleCompletion);
          resolve();
        } else if (type === 'error') {
          clearTimeout(timeoutId);
          workerRef.current?.removeEventListener('message', handleCompletion);
          reject(new Error(e.data.payload?.message || 'Unknown error'));
        }
      };
      
      // „É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É©„Éº„ÇíËøΩÂä†
      workerRef.current.addEventListener('message', handleCompletion);
      
      // „É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°
      workerRef.current.postMessage(message);
    });
  }, [isWorkerReady, addLog]);

  // ÂΩ¢Áä∂„ÅÆÁµêÂêà„Å®„É¨„É≥„ÉÄ„É™„É≥„Ç∞
  const combineAndRender = useCallback(async (options: CombineAndRenderPayload = {}): Promise<void> => {
    const workerManager = (window as any).cadWorkerManager;
    const isWorkerActuallyReady = workerManager?.isWorkerReady() || false;
    const worker = workerManager?.getWorker() || workerRef.current;
    
    if (!worker || !isWorkerActuallyReady) {
      throw new Error('Worker not ready');
    }

    // ÈÄ≤Ë°å‰∏≠„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ§∫„Åô
    setIsWorking(true);
    
    // „Éá„Éï„Ç©„É´„ÉàË®≠ÂÆö„Å®„Éû„Éº„Ç∏
    const defaultPayload: CombineAndRenderPayload = {
      maxDeviation: 0.1,
      sceneOptions: {
        groundPlaneVisible: true,
        gridVisible: true
      }
    };

    const payload: CombineAndRenderPayload = {
      ...defaultPayload,
      ...options,
      sceneOptions: {
        ...defaultPayload.sceneOptions,
        ...options.sceneOptions
      }
    };

    const message: CADWorkerMessage = {
      type: 'combineAndRenderShapes',
      payload
    };

    // Promise„Éô„Éº„Çπ„Åß„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°
    return new Promise((resolve, reject) => {
      if (!workerRef.current) {
        reject(new Error('Worker not available'));
        return;
      }
      
      // ‰∏ÄÂÆöÊôÇÈñìÂæå„Å´„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Ç®„É©„Éº„ÇíÁô∫Áîü„Åï„Åõ„Çã
      const timeoutId = setTimeout(() => {
        setIsWorking(false);
        const timeoutError = new Error('Combine and render operation timed out after 10 seconds');
        setError(timeoutError.message);
        addLog(`‚ùå ${timeoutError.message}`);
        reject(timeoutError);
      }, 10000);
      
      // ÂÆå‰∫Ü„Ç§„Éô„É≥„Éà„ÇíÂæÖÊ©ü„Åô„Çã„Éè„É≥„Éâ„É©„Éº
      const handleCompletion = (e: MessageEvent<CADWorkerResponse>) => {
        const { type } = e.data;
        if (type === 'combineAndRenderShapes') {
          clearTimeout(timeoutId);
          workerRef.current?.removeEventListener('message', handleCompletion);
          resolve();
        } else if (type === 'error') {
          clearTimeout(timeoutId);
          workerRef.current?.removeEventListener('message', handleCompletion);
          reject(new Error(e.data.payload?.message || 'Unknown error'));
        }
      };
      
      // „É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É©„Éº„ÇíËøΩÂä†
      workerRef.current.addEventListener('message', handleCompletion);
      
      // „É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°
      workerRef.current.postMessage(message);
    });
  }, [isWorkerReady, addLog]);

  // „É≠„Ç∞„ÅÆ„ÇØ„É™„Ç¢
  const clearLogs = useCallback(() => {
    setLogs([]);
  }, []);

  // „Ç®„É©„Éº„ÅÆ„ÇØ„É™„Ç¢
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // „ÉØ„Éº„Ç´„Éº„Å∏„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
  const sendToWorker = useCallback(async (message: { type: string; payload: any }) => {
    const workerManager = (window as any).cadWorkerManager;
    const isWorkerActuallyReady = workerManager?.isWorkerReady() || false;
    const worker = workerManager?.getWorker() || workerRef.current;
    
    if (!worker || !isWorkerActuallyReady) {
      console.error('CAD„ÉØ„Éº„Ç´„Éº„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
      return { success: false, error: 'Worker not ready' };
    }
    
    return new Promise((resolve) => {
      const messageId = Date.now().toString();
      
      // ÂøúÁ≠îÂæÖ„Å°„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
      const handleMessage = (e: MessageEvent) => {
        if (e.data.type === message.type) {
          // null„ÉÅ„Çß„ÉÉ„ÇØÂæå„Å´Âëº„Å≥Âá∫„Åó
          worker.removeEventListener('message', handleMessage);
          resolve(e.data.payload);
        }
      };
      
      worker.addEventListener('message', handleMessage);
      
      // „É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
      worker.postMessage({
        type: message.type,
        payload: message.payload,
        id: messageId
      });
    });
  }, []);

  return {
    worker: workerRef.current,
    isWorkerReady,
    isWorking,
    shapes,
    logs,
    error,
    progress,
    executeCADCode,
    combineAndRender,
    clearLogs,
    clearError,
    sendToWorker
  };
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                